<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>dfa_identify.encoding API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dfa_identify.encoding</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import inspect
from itertools import product
from functools import wraps
from typing import Any, Iterable, Literal, Optional, Union

import attr
import funcy as fn
import networkx as nx
from networkx.algorithms.approximation.clique import max_clique
from functools import partial

from dfa_identify.graphs import APTA, Node

Nodes = Iterable[Node]
Clauses = Iterable[list[int]]
Encodings = Iterable[Clauses]
SymMode = Optional[Literal[&#39;bfs&#39;, &#39;clique&#39;]]


# =================== Codec : int &lt;-&gt; variable  ====================


def encoder(offset):
    def _encoder(func):
        sig = inspect.signature(func)

        @wraps(func)
        def wrapper(self, *args, **kwargs):
            bound = sig.bind_partial(self, *args, **kwargs)
            for key, val in bound.arguments.items():
                if key.startswith(&#39;color&#39;):
                    assert 0 &lt;= val &lt; self.n_colors
                elif key.startswith(&#39;node&#39;):
                    assert 0 &lt;= val &lt; self.n_nodes
                elif key.startswith(&#39;token&#39;):
                    assert 0 &lt;= val &lt; self.n_tokens

            base = self.offsets[offset]
            return func(self, *args, **kwargs) + base
        return wrapper
    return _encoder


@attr.s(auto_detect=True, auto_attribs=True, frozen=True)
class AuxillaryVar:
    idx: int


@attr.s(auto_detect=True, auto_attribs=True, frozen=True)
class ColorAcceptingVar:
    color: int
    true: bool


@attr.s(auto_detect=True, auto_attribs=True, frozen=True)
class ColorNodeVar:
    color: int
    true: bool
    node: int


@attr.s(auto_detect=True, auto_attribs=True, frozen=True)
class ParentRelationVar:
    parent_color: int
    node_color: int
    token: int
    true: bool


Var = Union[ColorAcceptingVar, ColorNodeVar, ParentRelationVar, AuxillaryVar]


@attr.s(auto_detect=True, auto_attribs=True, frozen=True)
class Codec:
    n_nodes: int
    n_colors: int
    n_tokens: int
    sym_mode: SymMode

    def __attrs_post_init__(self):
        object.__setattr__(self, &#34;counts&#34;, (
            self.n_colors,                                    # z
            self.n_colors * self.n_nodes,                     # x
            self.n_tokens * self.n_colors * self.n_colors,    # y
            (self.n_colors * (self.n_colors - 1)) // 2,       # p
            (self.n_colors * (self.n_colors - 1)) // 2,       # t
            (self.n_colors - 1) * self.n_tokens,              # m
        ))
        object.__setattr__(self, &#34;offsets&#34;, tuple([0] + fn.lsums(self.counts)))

    @staticmethod
    def from_apta(apta: APTA,
                  n_colors: int = 0,
                  sym_mode: SymMode = None) -&gt; Codec:
        return Codec(len(apta.nodes), n_colors, len(apta.alphabet), sym_mode)

    @encoder(offset=0)
    def color_accepting(self, color: int) -&gt; int:
        &#34;&#34;&#34; Literature refers to these variables as z &#34;&#34;&#34;
        return 1 + color

    @encoder(offset=1)
    def color_node(self, node: int, color: int) -&gt; int:
        &#34;&#34;&#34; Literature refers to these variables as x &#34;&#34;&#34;
        return 1 + self.n_colors * node + color

    @encoder(offset=2)
    def parent_relation(self, token: Any, color1: int, color2: int) -&gt; int:
        &#34;&#34;&#34; Literature refers to these variables as y &#34;&#34;&#34;
        a = self.n_colors
        b = a**2
        return 1 + color1 + a * color2 + b * token

    # --------------------- BFS Sym_Mode Only ---------------------------
    @encoder(offset=3)
    def enumeration_parent(self, color1: int, color2: int) -&gt; int:
        &#34;&#34;&#34; Literature refers to these variables as p
        Note: here we use p_{i,j} rather than p_{j,i} &#34;&#34;&#34;
        assert (color1 &lt; color2), &#34;color1 must be smaller than color2&#34;
        return 1 + (((color2) * (color2 - 1)) // 2) + color1

    @encoder(offset=4)
    def transition_relation(self, color1: int, color2: int) -&gt; int:
        &#34;&#34;&#34; Literature refers to these variables as t &#34;&#34;&#34;
        assert (color1 &lt; color2), &#34;color1 must be smaller than color2&#34;
        return 1 + (((color2) * (color2 - 1)) // 2) + color1

    @encoder(offset=5)
    def enumeration_label(self, token: Any, color: int) -&gt; int:
        &#34;&#34;&#34; Literature refers to these variables as m &#34;&#34;&#34;
        assert color &gt; 0
        return 1 + self.n_tokens * (color - 1) + token

    # -------------------------------------------------------------------

    def decode(self, lit: int) -&gt; Var:
        idx = abs(lit) - 1
        color1, true = idx % self.n_colors, lit &gt; 0
        if idx &lt; self.offsets[1]:
            return ColorAcceptingVar(color1, true)
        elif idx &lt; self.offsets[2]:
            node = (idx - color1) // self.n_colors - 1
            return ColorNodeVar(color1, true, node)
        elif idx &lt; self.offsets[3]:
            tmp = idx - self.n_colors * (1 + self.n_nodes)
            tmp //= self.n_colors
            color2 = tmp % self.n_colors
            token = tmp // self.n_colors
            return ParentRelationVar(color1, color2, token, true)

        return AuxillaryVar(idx)


# ================= Clause Generator =====================


def dfa_id_encodings(apta: APTA, sym_mode: SymMode = None) -&gt; Encodings:
    cgraph = apta.consistency_graph()
    clique = max_clique(cgraph)

    for n_colors in range(len(clique), len(apta.nodes) + 1):
        codec = Codec.from_apta(apta, n_colors, sym_mode=sym_mode)
        yield codec, list(encode_dfa_id(apta, codec, cgraph, clique))


def encode_dfa_id(apta, codec, cgraph, clique=None):
    # Clauses from Table 1.                                      rows
    yield from onehot_color_clauses(codec)                      # 1, 5
    yield from partition_by_accepting_clauses(codec, apta)      # 2
    yield from colors_parent_rel_coupling_clauses(codec, apta)  # 3, 7
    yield from onehot_parent_relation_clauses(codec)            # 4, 6
    yield from determination_conflicts(codec, cgraph)           # 8
    if codec.sym_mode == &#34;clique&#34;:
        yield from symmetry_breaking(codec, clique)
    elif codec.sym_mode == &#34;bfs&#34;:
        yield from symmetry_breaking_common(codec)
        yield from symmetry_breaking_bfs(codec)


def onehot_color_clauses(codec: Codec) -&gt; Clauses:
    for n in range(codec.n_nodes):  # Each vertex has at least one color.
        yield [codec.color_node(n, c) for c in range(codec.n_colors)]

    for n in range(codec.n_nodes):  # Each vertex has at most one color.
        for i in range(codec.n_colors):
            lit = codec.color_node(n, i)
            for j in range(i + 1, codec.n_colors):  # i &lt; j
                yield [-lit, -codec.color_node(n, j)]


def tokensXcolors(codec: Codec):
    return product(range(codec.n_tokens), range(codec.n_colors))


def onehot_parent_relation_clauses(codec: Codec) -&gt; Clauses:
    # Each parent relation must target at least one color.
    for token, i in tokensXcolors(codec):
        colors = range(codec.n_colors)
        yield [codec.parent_relation(token, i, j) for j in colors]

    # Each parent relation can target at most one color.
    for token, i in tokensXcolors(codec):
        for h in range(codec.n_colors):
            lit1 = codec.parent_relation(token, i, h)
            for j in range(h + 1, codec.n_colors):  # h &lt; j
                yield [-lit1, -codec.parent_relation(token, i, j)]


def partition_by_accepting_clauses(codec: Codec, apta: APTA) -&gt; Clauses:
    for c in range(codec.n_colors):
        lit = codec.color_accepting(c)
        yield from ([-codec.color_node(n, c), lit] for n in apta.accepting)
        yield from ([-codec.color_node(n, c), -lit] for n in apta.rejecting)


def colors_parent_rel_coupling_clauses(codec: Codec, apta: APTA) -&gt; Clauses:
    colors = range(codec.n_colors)
    rev_tree = apta.tree.reverse()
    non_root_nodes = set(apta.nodes) - {0}     # Root doesn&#39;t have a parent.
    for node, i, j in product(non_root_nodes, colors, colors):
        parent, *_ = rev_tree.neighbors(node)  # only have 1 parent.
        token = apta.alphabet[apta.nodes[node][&#39;source&#39;]]

        parent_color = codec.color_node(parent, i)
        node_color = codec.color_node(node, j)
        parent_rel = codec.parent_relation(token, i, j)

        # Parent relation and node color coupled throuh parent color.
        yield [-parent_color, -node_color, parent_rel]  # 3
        yield [-parent_color, node_color, -parent_rel]  # 7


def determination_conflicts(codec: Codec, cgraph: nx.Graph) -&gt; Clauses:
    colors = range(codec.n_colors)
    for (n1, n2), c in product(cgraph.edges, colors):
        yield [-codec.color_node(n1, c), -codec.color_node(n2, c)]


def symmetry_breaking(codec: Codec, clique: Nodes) -&gt; Clauses:
    for color, node in enumerate(clique):
        yield [codec.color_node(node, color)]


def symmetry_breaking_common(codec: Codec) -&gt; Clauses:
    &#34;&#34;&#34;
    Symmetry breaking clauses for both DFS and BFS
    See Ulyantsev 2016.
    &#34;&#34;&#34;
    # Ensures start vertex is 0 - not listed in Ulyantsev
    yield [codec.color_node(0, 0)]

    for color2 in range(codec.n_colors):
        if color2 &gt; 0:
            yield [
                codec.enumeration_parent(color1, color2)
                for color1 in range(color2)
            ]  # 4
        for color1 in range(color2):
            p = codec.enumeration_parent(color1, color2)
            t = codec.transition_relation(color1, color2)
            m = partial(codec.enumeration_label, color=color2)
            y = partial(codec.parent_relation, color1=color1, color2=color2)

            yield [-t] + [y(token) for token in range(codec.n_tokens)]  # 1
            yield [t, -p]  # 3

            for token2 in range(codec.n_tokens):
                yield [t, -y(token2)]  # 2
                yield [-p, -m(token2), y(token2)]  # 5
                yield [-y(token2), -p, m(token2)] + \
                    [y(token1) for token1 in range(token2)]  # 7

                for token1 in range(token2):
                    yield [-p, -m(token2), -y(token1)]  # 6


def symmetry_breaking_bfs(codec: Codec) -&gt; Clauses:
    &#34;&#34;&#34;
    Symmetry breaking clauses for BFS
    See Ulyantsev 2016.
    &#34;&#34;&#34;
    for color2 in range(codec.n_colors):
        t_2 = partial(codec.transition_relation, color2=color2)
        for color1 in range(color2):
            p12 = codec.enumeration_parent(color1, color2)
            t12 = codec.transition_relation(color1, color2)

            yield from [[-p12, -t_2(color3)] for color3 in range(color1)]  # 12
            yield [-t12, p12] + [t_2(color3) for color3 in range(color1)]  # 13

            if color2 + 1 &gt;= codec.n_colors:
                continue

            for color3 in range(color1):  # 14
                yield [-p12, -codec.enumeration_parent(color3, color2 + 1)]

            for token2 in range(codec.n_tokens):
                for token1 in range(token2):
                    yield [
                        -p12,
                        -codec.enumeration_parent(color1, color2 + 1),
                        -codec.enumeration_label(token2, color2),
                        -codec.enumeration_label(token1, color2 + 1),
                    ]  # 15


__all__ = [&#39;Codec&#39;, &#39;dfa_id_encodings&#39;]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dfa_identify.encoding.dfa_id_encodings"><code class="name flex">
<span>def <span class="ident">dfa_id_encodings</span></span>(<span>apta: APTA, sym_mode: SymMode = None) ‑> Iterable[Iterable[list[int]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dfa_id_encodings(apta: APTA, sym_mode: SymMode = None) -&gt; Encodings:
    cgraph = apta.consistency_graph()
    clique = max_clique(cgraph)

    for n_colors in range(len(clique), len(apta.nodes) + 1):
        codec = Codec.from_apta(apta, n_colors, sym_mode=sym_mode)
        yield codec, list(encode_dfa_id(apta, codec, cgraph, clique))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dfa_identify.encoding.Codec"><code class="flex name class">
<span>class <span class="ident">Codec</span></span>
<span>(</span><span>n_nodes: int, n_colors: int, n_tokens: int, sym_mode: SymMode)</span>
</code></dt>
<dd>
<div class="desc"><p>Method generated by attrs for class Codec.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@attr.s(auto_detect=True, auto_attribs=True, frozen=True)
class Codec:
    n_nodes: int
    n_colors: int
    n_tokens: int
    sym_mode: SymMode

    def __attrs_post_init__(self):
        object.__setattr__(self, &#34;counts&#34;, (
            self.n_colors,                                    # z
            self.n_colors * self.n_nodes,                     # x
            self.n_tokens * self.n_colors * self.n_colors,    # y
            (self.n_colors * (self.n_colors - 1)) // 2,       # p
            (self.n_colors * (self.n_colors - 1)) // 2,       # t
            (self.n_colors - 1) * self.n_tokens,              # m
        ))
        object.__setattr__(self, &#34;offsets&#34;, tuple([0] + fn.lsums(self.counts)))

    @staticmethod
    def from_apta(apta: APTA,
                  n_colors: int = 0,
                  sym_mode: SymMode = None) -&gt; Codec:
        return Codec(len(apta.nodes), n_colors, len(apta.alphabet), sym_mode)

    @encoder(offset=0)
    def color_accepting(self, color: int) -&gt; int:
        &#34;&#34;&#34; Literature refers to these variables as z &#34;&#34;&#34;
        return 1 + color

    @encoder(offset=1)
    def color_node(self, node: int, color: int) -&gt; int:
        &#34;&#34;&#34; Literature refers to these variables as x &#34;&#34;&#34;
        return 1 + self.n_colors * node + color

    @encoder(offset=2)
    def parent_relation(self, token: Any, color1: int, color2: int) -&gt; int:
        &#34;&#34;&#34; Literature refers to these variables as y &#34;&#34;&#34;
        a = self.n_colors
        b = a**2
        return 1 + color1 + a * color2 + b * token

    # --------------------- BFS Sym_Mode Only ---------------------------
    @encoder(offset=3)
    def enumeration_parent(self, color1: int, color2: int) -&gt; int:
        &#34;&#34;&#34; Literature refers to these variables as p
        Note: here we use p_{i,j} rather than p_{j,i} &#34;&#34;&#34;
        assert (color1 &lt; color2), &#34;color1 must be smaller than color2&#34;
        return 1 + (((color2) * (color2 - 1)) // 2) + color1

    @encoder(offset=4)
    def transition_relation(self, color1: int, color2: int) -&gt; int:
        &#34;&#34;&#34; Literature refers to these variables as t &#34;&#34;&#34;
        assert (color1 &lt; color2), &#34;color1 must be smaller than color2&#34;
        return 1 + (((color2) * (color2 - 1)) // 2) + color1

    @encoder(offset=5)
    def enumeration_label(self, token: Any, color: int) -&gt; int:
        &#34;&#34;&#34; Literature refers to these variables as m &#34;&#34;&#34;
        assert color &gt; 0
        return 1 + self.n_tokens * (color - 1) + token

    # -------------------------------------------------------------------

    def decode(self, lit: int) -&gt; Var:
        idx = abs(lit) - 1
        color1, true = idx % self.n_colors, lit &gt; 0
        if idx &lt; self.offsets[1]:
            return ColorAcceptingVar(color1, true)
        elif idx &lt; self.offsets[2]:
            node = (idx - color1) // self.n_colors - 1
            return ColorNodeVar(color1, true, node)
        elif idx &lt; self.offsets[3]:
            tmp = idx - self.n_colors * (1 + self.n_nodes)
            tmp //= self.n_colors
            color2 = tmp % self.n_colors
            token = tmp // self.n_colors
            return ParentRelationVar(color1, color2, token, true)

        return AuxillaryVar(idx)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="dfa_identify.encoding.Codec.n_colors"><code class="name">var <span class="ident">n_colors</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dfa_identify.encoding.Codec.n_nodes"><code class="name">var <span class="ident">n_nodes</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dfa_identify.encoding.Codec.n_tokens"><code class="name">var <span class="ident">n_tokens</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dfa_identify.encoding.Codec.sym_mode"><code class="name">var <span class="ident">sym_mode</span> : Optional[Literal['bfs', 'clique']]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="dfa_identify.encoding.Codec.from_apta"><code class="name flex">
<span>def <span class="ident">from_apta</span></span>(<span>apta: APTA, n_colors: int = 0, sym_mode: SymMode = None) ‑> <a title="dfa_identify.encoding.Codec" href="#dfa_identify.encoding.Codec">Codec</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_apta(apta: APTA,
              n_colors: int = 0,
              sym_mode: SymMode = None) -&gt; Codec:
    return Codec(len(apta.nodes), n_colors, len(apta.alphabet), sym_mode)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dfa_identify.encoding.Codec.color_accepting"><code class="name flex">
<span>def <span class="ident">color_accepting</span></span>(<span>self, color: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Literature refers to these variables as z</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@encoder(offset=0)
def color_accepting(self, color: int) -&gt; int:
    &#34;&#34;&#34; Literature refers to these variables as z &#34;&#34;&#34;
    return 1 + color</code></pre>
</details>
</dd>
<dt id="dfa_identify.encoding.Codec.color_node"><code class="name flex">
<span>def <span class="ident">color_node</span></span>(<span>self, node: int, color: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Literature refers to these variables as x</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@encoder(offset=1)
def color_node(self, node: int, color: int) -&gt; int:
    &#34;&#34;&#34; Literature refers to these variables as x &#34;&#34;&#34;
    return 1 + self.n_colors * node + color</code></pre>
</details>
</dd>
<dt id="dfa_identify.encoding.Codec.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, lit: int) ‑> Union[dfa_identify.encoding.ColorAcceptingVar, dfa_identify.encoding.ColorNodeVar, dfa_identify.encoding.ParentRelationVar, dfa_identify.encoding.AuxillaryVar]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, lit: int) -&gt; Var:
    idx = abs(lit) - 1
    color1, true = idx % self.n_colors, lit &gt; 0
    if idx &lt; self.offsets[1]:
        return ColorAcceptingVar(color1, true)
    elif idx &lt; self.offsets[2]:
        node = (idx - color1) // self.n_colors - 1
        return ColorNodeVar(color1, true, node)
    elif idx &lt; self.offsets[3]:
        tmp = idx - self.n_colors * (1 + self.n_nodes)
        tmp //= self.n_colors
        color2 = tmp % self.n_colors
        token = tmp // self.n_colors
        return ParentRelationVar(color1, color2, token, true)

    return AuxillaryVar(idx)</code></pre>
</details>
</dd>
<dt id="dfa_identify.encoding.Codec.enumeration_label"><code class="name flex">
<span>def <span class="ident">enumeration_label</span></span>(<span>self, token: Any, color: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Literature refers to these variables as m</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@encoder(offset=5)
def enumeration_label(self, token: Any, color: int) -&gt; int:
    &#34;&#34;&#34; Literature refers to these variables as m &#34;&#34;&#34;
    assert color &gt; 0
    return 1 + self.n_tokens * (color - 1) + token</code></pre>
</details>
</dd>
<dt id="dfa_identify.encoding.Codec.enumeration_parent"><code class="name flex">
<span>def <span class="ident">enumeration_parent</span></span>(<span>self, color1: int, color2: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Literature refers to these variables as p
Note: here we use p_{i,j} rather than p_{j,i}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@encoder(offset=3)
def enumeration_parent(self, color1: int, color2: int) -&gt; int:
    &#34;&#34;&#34; Literature refers to these variables as p
    Note: here we use p_{i,j} rather than p_{j,i} &#34;&#34;&#34;
    assert (color1 &lt; color2), &#34;color1 must be smaller than color2&#34;
    return 1 + (((color2) * (color2 - 1)) // 2) + color1</code></pre>
</details>
</dd>
<dt id="dfa_identify.encoding.Codec.parent_relation"><code class="name flex">
<span>def <span class="ident">parent_relation</span></span>(<span>self, token: Any, color1: int, color2: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Literature refers to these variables as y</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@encoder(offset=2)
def parent_relation(self, token: Any, color1: int, color2: int) -&gt; int:
    &#34;&#34;&#34; Literature refers to these variables as y &#34;&#34;&#34;
    a = self.n_colors
    b = a**2
    return 1 + color1 + a * color2 + b * token</code></pre>
</details>
</dd>
<dt id="dfa_identify.encoding.Codec.transition_relation"><code class="name flex">
<span>def <span class="ident">transition_relation</span></span>(<span>self, color1: int, color2: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Literature refers to these variables as t</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@encoder(offset=4)
def transition_relation(self, color1: int, color2: int) -&gt; int:
    &#34;&#34;&#34; Literature refers to these variables as t &#34;&#34;&#34;
    assert (color1 &lt; color2), &#34;color1 must be smaller than color2&#34;
    return 1 + (((color2) * (color2 - 1)) // 2) + color1</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dfa_identify" href="index.html">dfa_identify</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dfa_identify.encoding.dfa_id_encodings" href="#dfa_identify.encoding.dfa_id_encodings">dfa_id_encodings</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dfa_identify.encoding.Codec" href="#dfa_identify.encoding.Codec">Codec</a></code></h4>
<ul class="two-column">
<li><code><a title="dfa_identify.encoding.Codec.color_accepting" href="#dfa_identify.encoding.Codec.color_accepting">color_accepting</a></code></li>
<li><code><a title="dfa_identify.encoding.Codec.color_node" href="#dfa_identify.encoding.Codec.color_node">color_node</a></code></li>
<li><code><a title="dfa_identify.encoding.Codec.decode" href="#dfa_identify.encoding.Codec.decode">decode</a></code></li>
<li><code><a title="dfa_identify.encoding.Codec.enumeration_label" href="#dfa_identify.encoding.Codec.enumeration_label">enumeration_label</a></code></li>
<li><code><a title="dfa_identify.encoding.Codec.enumeration_parent" href="#dfa_identify.encoding.Codec.enumeration_parent">enumeration_parent</a></code></li>
<li><code><a title="dfa_identify.encoding.Codec.from_apta" href="#dfa_identify.encoding.Codec.from_apta">from_apta</a></code></li>
<li><code><a title="dfa_identify.encoding.Codec.n_colors" href="#dfa_identify.encoding.Codec.n_colors">n_colors</a></code></li>
<li><code><a title="dfa_identify.encoding.Codec.n_nodes" href="#dfa_identify.encoding.Codec.n_nodes">n_nodes</a></code></li>
<li><code><a title="dfa_identify.encoding.Codec.n_tokens" href="#dfa_identify.encoding.Codec.n_tokens">n_tokens</a></code></li>
<li><code><a title="dfa_identify.encoding.Codec.parent_relation" href="#dfa_identify.encoding.Codec.parent_relation">parent_relation</a></code></li>
<li><code><a title="dfa_identify.encoding.Codec.sym_mode" href="#dfa_identify.encoding.Codec.sym_mode">sym_mode</a></code></li>
<li><code><a title="dfa_identify.encoding.Codec.transition_relation" href="#dfa_identify.encoding.Codec.transition_relation">transition_relation</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>